- Promise is a object 
 -const response = await PromiseFive write in variable because promise are object 

 =========================================  .then =========================================

 ğŸ“˜ Promises, .then(), .catch(), async/await â€” Simple Notes
ğŸ”¹ What is a Promise?

A Promise represents future value

It has only ONE result

âœ… resolve (success)

âŒ reject (error)

A Promise can resolve or reject only once

ğŸ”¹ .then() and .catch() are asynchronous

.then() runs when Promise resolves

.catch() runs when Promise rejects

They run using microtask queue

They do NOT run immediately

ğŸ“Œ Promise executor runs immediately, but .then() runs later

ğŸ”¹ Why we write response in .then((response)=>{})

.then() gives the resolved value

We need a variable name to receive it

response is just a parameter name, not keyword

âœ” response, res, data, anything works

ğŸ”¹ What does return do in .then()
.then(response => {
   return response.json();
})


response.json() returns a Promise

return passes it to the next .then()

Without return â†’ next .then() gets undefined

ğŸ“Œ return connects Promise chains

ğŸ”¹ Why console.log(response.json()) does NOT work

response.json() is a Promise

Data is not ready immediately

console.log() prints:

Promise { <pending> }


âœ” Correct ways:

response.json().then(data => console.log(data));


or

const data = await response.json();

ğŸ”¹ Why response.json() is a Promise

Response body is a stream

Reading & converting JSON takes time

So it works asynchronously

ğŸ“Œ Because itâ€™s a Promise, it needs .then() or await

ğŸ”¹ Multiple .then() means what?

âŒ It does NOT mean multiple resolves
âœ… It means Promise chaining

ğŸ“Œ Each .then() returns a NEW Promise

Promise.resolve(5)
  .then(x => x + 1)   // new Promise
  .then(x => x * 2);  // new Promise

ğŸ”¹ Do we need multiple .catch()?

âŒ NO

âœ” One .catch() at the end is enough

.then(...)
.then(...)
.then(...)
.catch(error => console.log(error))


ğŸ“Œ Error in any .then() goes to the same .catch()

ğŸ”¹ If we use only ONE .then()

âœ” Still need .catch()

Because errors can happen in:

fetch

response.json

logic inside .then()

ğŸ“Œ Rule:

If you use .then(), always use .catch()

ğŸ”¹ async / await basics

async/await is asynchronous

It only looks synchronous

Uses Promises internally

ğŸ“Œ Important rule:

await pauses only its own async function

ğŸ”¹ Multiple await in same function

Runs one by one (sequential)

JS thread is NOT blocked

ğŸ”¹ Multiple async functions

Run independently

Faster one finishes first

They donâ€™t know about each other unless connected

ğŸ”¹ Common Promise mistake (IMPORTANT)
await new Promise(() => {
   console.log("Task 1");
});


âŒ Promise never resolves
âŒ await waits forever

âœ” Always call resolve() or reject()

â­ MOST IMPORTANT MEMORY LINES (WRITE THIS)

A Promise resolves only once

Each .then() returns a new Promise

One .catch() can handle all errors

return passes data to next .then()

response.json() is a Promise

await blocks function, not JavaScript

ğŸ”¥ Perfect Interview One-Liners

.then() and .catch() are asynchronous handlers of Promises

response.json() returns a Promise, not data

Multiple .then() does not mean multiple resolves

One .catch() is enough for Promise chaining

